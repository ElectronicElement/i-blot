var config = require('config');
var Buffer = require('safe-buffer').Buffer;
var compressible = require('compressible');
var debug = require('debug')('compression');
var onHeaders = require('on-headers');
var fs = require('fs-extra');
var basename = require('path').basename;
var guid = require('helper').guid;
var join = require('path').join;
debug = console.log;

module.exports = disk_cache;
module.exports.filter = shouldCompress;

var cacheControlNoTransformRegExp = /(?:^|,)\s*?no-transform\s*?(?:,|$)/;
var cacheControlNoCache = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;


// this seems to have a bug with res.send
// it never ends the response?
// res.write + res.end works fine instead

function disk_cache (req, res, next) {

  var fullurl = req.originalUrl;

  var ended = false;
  var listeners = [];
  var stream;

  var _end = res.end;
  var _on = res.on;
  var _write = res.write;

  // proxy
  res.write = function write (chunk, encoding) {

    if (ended) {
      return false;
    }

    debug('WRITE', '(stream exists:'+!!stream+')', '(has ended flag:'+ended+')', fullurl, chunk.toString().slice(0, 15));

    if (!this._header) {
      this._implicitHeader();
    }

    if (stream) {
      stream.write(Buffer.from(chunk, encoding));
    }

    return _write.call(this, chunk, encoding);
  };

  res.end = function end (chunk, encoding) {

    if (ended) {
      return false;
    }

    if (!this._header) {
      this._implicitHeader();
    }

    if (chunk)  debug('END  ', '(stream exists:'+!!stream+')', '(has ended flag:'+ended+')', fullurl, chunk.toString().slice(0, 15));
    if (!chunk) debug('END  ','(stream exists:'+!!stream+')', '(has ended flag:'+ended+')', fullurl);

    if (!stream) {
      return _end.call(this, chunk, encoding);
    }

    // mark ended

    if (chunk) {
      ended = true; 
      _end.call(this, chunk, encoding);
      return stream.end(Buffer.from(chunk, encoding));
    }

    if (!chunk) {
      ended = true;
      _end.call(this);
      return stream.end();
    }
  };

  res.on = function on (type, listener) {
    if (!listeners || type !== 'drain') {
      return _on.call(this, type, listener);
    }

    if (stream) {
      return stream.on(type, listener);
    }

    // buffer listeners for future stream
    listeners.push([type, listener]);

    return this;
  };

  function nocompress (msg) {
    debug('no compression: %s', msg);
    addListeners(res, _on, listeners);
    listeners = null;
  }

    onHeaders(res, function onResponseHeaders () {

      if (req.session && req.session.uid) {
        nocompress('has session');
        return;
      } 
      
      // determine if the entity should be transformed
      if (!shouldTransform(req, res)) {
        nocompress('no transform');
        return;
      }

      if (!shouldCache(req, res)) {
        nocompress('no cache');
        return;
      }

      // head
      if (req.method === 'HEAD') {
        nocompress('HEAD request');
        return;
      } 

      if (res.statusCode !== 200) {
        nocompress('BAD status');
        return;
      }

      if (Object.keys(req.query).length) {
        nocompress('Has query string');
        return;        
      }

      // compression stream
      debug('Creating stream');
      var tmp_output = __dirname + '/out/' + guid() + basename(req.baseUrl + req.path);
      stream = fs.createWriteStream(tmp_output);

      // add buffered listeners to stream
      addListeners(stream, stream.on, listeners);

      stream.on('error', function(err){
        debug(err);
      });

      stream.on('finish', function onStreamEnd () {
          
        console.log('stream has finished');

        stream.close();
          
        var contentType = res.getHeader('Content-Type');
        var cache_age = res.getHeader('Cache-Control') && res.getHeader('Cache-Control').indexOf('max-age') > -1 ? 'permanent' : 'temporary';
        var final_output = join(config.cache_directory, req.hostname, req.protocol, cache_age, req.originalUrl);

        if (contentType.indexOf('text/html') > -1 && req.path.indexOf('.') === -1)  {
          final_output  = join(final_output, 'index.html');
        }

        fs.move(tmp_output, final_output, {overwrite: true}, function(err){

          if (err) throw err;

        });  
      });

    });

    next();
  }

/**
 * Add bufferred listeners to stream
 * @private
 */

function addListeners (stream, on, listeners) {
  for (var i = 0; i < listeners.length; i++) {
    on.apply(stream, listeners[i]);
  }
}


function shouldCompress (req, res) {
  var type = res.getHeader('Content-Type');

  if (type === undefined || !compressible(type)) {
    debug('%s not compressible', type);
    return false;
  }

  return true;
}

function shouldCache (req, res) {

  var cacheControl = res.getHeader('Cache-Control');
  
  // Don't compress for Cache-Control: no-cache
  // https://tools.ietf.org/html/rfc7234#section-5.2.2.4
  return !cacheControl || !cacheControlNoCache.test(cacheControl);
}

function shouldTransform (req, res) {
  var cacheControl = res.getHeader('Cache-Control');

  // Don't compress for Cache-Control: no-transform
  // https://tools.ietf.org/html/rfc7234#section-5.2.2.4
  return !cacheControl ||
    !cacheControlNoTransformRegExp.test(cacheControl);
}