var express = require('express');
var Buffer = require('safe-buffer').Buffer;
var app  = express();
var fs = require('fs-extra');
var onHeaders = require('on-headers');

app.use(function(req, res, next){

  var debug = console.log.bind(this, req.hostname + req.originalUrl);

  var _write = res.write;
  var _end = res.end;
  var ended = false;
  var stream;
  
  res.write = function(chunk, encoding) {

    debug('write called', chunk, encoding);

    // Trigger the onHeaders function below
    // if we have not set any headers ourselves
    if (!this._header) this._implicitHeader();

    // The return value of response.write is meaningful
    // in a way I quite don't understand. So we store the
    // return value of the original response write function
    // and use it later. 
    var return_value = _write.call(this, chunk, encoding);

    // We only write to the stream (if it exists) if we have
    // not triggered the 'ended' flag in our custom end function
    // below. This prevents a 'double write' when calling
    // end with a final chunk of data
    if (!ended && stream) stream.write(Buffer.from(chunk, encoding));

    return return_value;
  };

  res.end = function(chunk, encoding) {

    debug('end called', chunk, encoding);
    
    // Trigger the onHeaders function below
    // if we have not set any headers ourselves
    if (!this._header) this._implicitHeader();

    // This flag is used to prevent a 'double write'
    // if response.end is invoked with a chunk of data
    // Basically, you can end a response with some final
    // piece of data, or without. Calling response.end
    // with data neccessarily invokes response.write
    // for a reason I don't  quite yet understand,
    // So we set this flag before calling _end 
    ended = true;

    // Again, the return value of the end function
    // is meaningful so we save it for future use.
    var return_value = _end.call(this, chunk, encoding);

    if (chunk && stream) {
      stream.end(Buffer.from(chunk, encoding));
    } else if (stream) {
      stream.end();
    }

    return return_value;
  };

  onHeaders(res, function onResponseHeaders () {

    if (res.statusCode !== 200) return;

    stream = fs.createWriteStream(__dirname + '/output' + req.path + '.html');

    stream.on('close', function(){
      debug('stream closed');
    });
  });

  next();
});

app.get('/send', function(req, res){
  res.send('Woo!');
}); 

app.get('/sendFile', function(req, res){
  res.sendFile(__dirname + '/testfile.html');
}); 
app.get('/sendStatus', function(req, res){
  res.sendStatus(200);
}); 

app.get('/writewriteend', function(req, res){
  res.write('Hello ');
  res.write('World');
  res.end('!');
}); 

app.get('/writewrite', function(req, res){
  res.write('Goodbye ');
  res.write('World');
  res.end();
}); 


app.use(function(req, res){
  res.sendStatus(404);
});

app.listen(8777);