var Buffer = require('safe-buffer').Buffer;
var fs = require('fs-extra');
var onHeaders = require('on-headers');
var cacheControlNoCache = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
var basename = require('path').basename;
var guid = require('helper').guid;
var join = require('path').join;
var config = require('config');
var tmp_dir = helper.tempDir();

function disk_cache (req, res, next){

  var debug = console.log.bind(this, req.hostname + req.originalUrl);

  var _write = res.write;
  var _end = res.end;
  var ended = false;
  var stream;
  
  res.write = function(chunk, encoding) {

    debug('write called', chunk, encoding);

    // Trigger the onHeaders function below
    // if we have not set any headers ourselves
    if (!this._header) this._implicitHeader();

    // The return value of response.write is meaningful
    // in a way I quite don't understand. So we store the
    // return value of the original response write function
    // and use it later. 
    var return_value = _write.call(this, chunk, encoding);

    // We only write to the stream (if it exists) if we have
    // not triggered the 'ended' flag in our custom end function
    // below. This prevents a 'double write' when calling
    // end with a final chunk of data
    if (!ended && stream) stream.write(Buffer.from(chunk, encoding));

    return return_value;
  };

  res.end = function(chunk, encoding) {

    debug('end called', chunk, encoding);
    
    // Trigger the onHeaders function below
    // if we have not set any headers ourselves
    if (!this._header) this._implicitHeader();

    // This flag is used to prevent a 'double write'
    // if response.end is invoked with a chunk of data
    // Basically, you can end a response with some final
    // piece of data, or without. Calling response.end
    // with data neccessarily invokes response.write
    // for a reason I don't  quite yet understand,
    // So we set this flag before calling _end 
    ended = true;

    // Again, the return value of the end function
    // is meaningful so we save it for future use.
    var return_value = _end.call(this, chunk, encoding);

    if (chunk && stream) {
      stream.end(Buffer.from(chunk, encoding));
    } else if (stream) {
      stream.end();
    }

    return return_value;
  };

  onHeaders(res, function onResponseHeaders () {

    if (req.session && req.session.uid) {
      debug('has session');
      return;
    } 
    
    if (!shouldCache(req, res)) {
      debug('no cache');
      return;
    }

    // head
    if (req.method === 'HEAD') {
      debug('HEAD request');
      return;
    } 

    if (res.statusCode !== 200) {
      debug('BAD status ' + req.originalUrl + ' ' + res.statusCode);
      return;
    }

    if (Object.keys(req.query).length) {
      debug('Has query string');
      return;        
    }

    var tmp_output = tmp_dir + guid() + basename(req.baseUrl + req.path);
    stream = fs.createWriteStream(tmp_output);

    stream.on('error', function(err){
      debug(err);
    });

    stream.on('finish', function onStreamEnd () {
        
      debug('stream has finished');

      stream.close();
        
      var contentType = res.getHeader('Content-Type');
      var cache_age = res.getHeader('Cache-Control') && res.getHeader('Cache-Control').indexOf('max-age') > -1 ? 'permanent' : 'temporary';
      var final_output = join(config.cache_directory, req.hostname, req.protocol, cache_age, req.originalUrl);

      if (contentType.indexOf('text/html') > -1 && req.path.indexOf('.') === -1)  {
        final_output  = join(final_output, 'index.html');
      }

      fs.move(tmp_output, final_output, {overwrite: true}, function(err){

        if (err) throw err;

      });  
    });
  });

  next();
}

function shouldCache (req, res) {

  var cacheControl = res.getHeader('Cache-Control');
  
  // Don't compress for Cache-Control: no-cache
  // https://tools.ietf.org/html/rfc7234#section-5.2.2.4
  return !cacheControl || !cacheControlNoCache.test(cacheControl);
}


module.exports = disk_cache;